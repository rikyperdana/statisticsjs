# 6. Journey Through Time

Data time series adalah adata dimana salah satu dimensinya adalah waktu. Dimensi waktu ini biasanya memiliki interval yang homogen, contohnya data tahunan, bulanan, mingguan, harian, jam, menit, hingga detik. Disebut homogen karena tidak boleh mencampurkan data tahunan dan harian dalam 1 kelompok data yang sama. Data time series (berurut waktu) juga biasanya tersusun secara serial (interval yang terjaga tanpa ada unit waktu yang terlewat, walau tidak mutlak wajib). Konsistensi dan serialisasi mencirikan kelompok ata time series yang bagus untuk dianalisa. Pada umumnya data time series dikumpulkan dan dianalisa untuk tujuan peramalan nilai data berikutnya yang belum terjadi berdasarkan telaahan data historis yang telah berlalu. Sebenarnya data time seris dapat digunakan untuk tujuan hal diluar peramalan seperti korelasi dan kausali tas, tapi buku ini akan fokus dulu pada tujuan peramalan.

Sekarang Anda telah tahu bahwa salah satu dimensinya adalah waktu, lalu dimensi apa yang bisa menjadi pasangannya? Bisa apapun! Selagi nilainya bersifat interval atau rasio. Bisa juga untuk data ordinal walau tidak lumrah. Yang jelas tidak bisa untuk data nominal yang sifatnya klasifikasi. Apa contoh data interval yang bisa diramalkan? Banyak! Mulai dari ramalan cuaca, penjualan produk, sampai pergerakan benda kosmik. Namun perlu diingat bahwa yang namanya peramalan akan selalu bersifat probabilistik, dimana hasil perkiraan hanya bisa mendekati realita pada titik waktu yang diramalkan. Dan bilamana ada hasil ramalan yang eksak sama dengan realita yang terjadi maka itu adalah murni kebetulan belaka. Hal terbaik yang bisa dilakukan ahli statistik adalah memilih alat yang tepat, sumber data yang baik, dan membuat persamaan ramalan yang paling mampu mendekati realita.

Teknik peramalan yang akan digunakan oleh seorang ahli statistik tergantung pada pola trend mana yang tampak pada grafik. Secara umum pola tersebut ada yang linear (garis lurus), cyclical (bersiklus), seasonal (musiman), dan residual. Menggunakan teknik peramalan linear pada pola cyclical tentu akan menghasilkan ramalan yang jauh dari ekspektasi dan realita, begitu pula dengan pola lainnya. Maka dari itu, langkah pertama dalam peramalan justru adalah menggambar grafik, agar ahli statistiknya dapat melakukan inspeksi visual dan mengklasifikasikan pola apa yang tampak pada grafik tersebut.

Tahapan kedua adalah memilih alat statistik mana yang akan digunakan, ini panduannya:
A. Pola Linier:
1. Freehand (tangan bebas)
2. Half average (setengah rata-rata)
3. Moving average (rata-rata bergerak)
4. Least square (kuadrat terkecil)
5. Mathematical model (model matematis)

B. Pola Cyclical:
1. Quadratic equation (persamaan kuadrat)

C. Pola Seasonal:
1. Total average (rata-rata total)
2. Simple average (rata-rata sederhana)
3. Ratio method (metode rasio)
4. Moving ratio (rasio bergerak)

Lumayan beragam juga kan teknik peramalan untuk setiap pola? Selain dari yang ditunjukkan diatas, di luar sana masih lebih banyak lagi metode peramalan berbasis statistik yang jauh lebih advanced, bahkan artificial intelligence (kecerdasan buatan) diciptakan juga untuk melakukan peramalan data. Sebagai contoh gambar seekor kucing dalam resolusi 100*100 pixel dikonversi menjadi data himpunan 10000 integer, diajarkan bahwa himpunan data itu adalah citra kucing. Lakukan ulang untuk beberapa ratus ribu foto kucing lainnya dengan dimensi piksel yang sama, bila rancangan AI-nya memang bagus, pada foto berikutnya ia bisa menebak apakah dalam foto yang baru ada kucingnya atau tidak. Itu adalah salah satu contoh paling kompleks dari pemanfaatan model matematis untuk peramalan data. Dalam buku ini kita cukup memulai dengan statistik yang sederhana untuk peramalan data hingga memperoleh informasi yang berharga.

## 6.1. Metode Freehand
Metode ini adalah metode peramalan berbasis grafik yang paling mudah (malas?). Bahkan diragukan bahwa ia masuk kedalam kategori statistik atau tidak. Karena dalam metode freehand sama sekali tidak menggunakan perhitungan matematis melainkan kemampuan individu seseorang untuk melakukan inspeksi visual, interpretasi trend, dan menggambar lanjutan grafik tersebut cukup dengan menggunakan tangan. Berikut ini adalah contoh grafik sederhana berikut dengan contoh freehandnya.

Cara melakukan peramalan freehand:
1. Gambarkan sebuah grafik berdasarkan suatu set data pada kertas
2. Ambil penggaris transparan, letakkan diatas grafik sehingga tepinya membentuk garis lurus yang berposisi paling mendekati bentuk lurus grafik tersebut
3. Gunakan pensil, buat garis baru berdasarkan tepian penggaris tersebut
4. Hasil peramalan garis lurus berdasarkan metode freehand siap dihidangkan

Berikut ini adalah daftar kelebihan freehand:
1. Tidak memerlukan perhitungan matematis
2. Jika dilakukan oleh orang yang berpengalaman melakukan freehand maka hasilnya mungkin dapat mendekati hasil perhitungan matematis

Tapi kelemahannya adalah sebagai berikut:
1. Ketepatan bergantung pada pengalaman subjektif individu penggambar
2. Hasil dapat inkonsisten antara satu penggambar dengan penggambar yang lain
3. Sulit untuk mengajukan argumen kuantitatif berdasarkan keputusan subjektif

## 6.2. Semi average
Bila dalam metode freehand kita menyerahkan justifikasi garis lurus kepada si penggambarnya, maka dalam semi average kita menyerahkan penggaris tersebut kepada matematika. Artinya garis lurus yang paling mewakili sebuah grafik tidak lagi dikerjakan secara subjektif melainkan sudah secara kuantatif oleh model matematika.

Cara kerja metode semi average:
1. Buat tabel dengan 3 kolom (tahun, nilai, semitotal, semiaverage)
2. Setiap barisnya mewakili nilai pada tahun tersebut
3. Bagi dua data tersebut berdasarkan rentang tahun
4. Untuk setiap bagian, jumlahkan nilainya dan bagi dengan panjang rentang bagian tersebut
5. Sekarang kita sudah mendapatkan 2 angka (part 1, dan part 2) sebagai pivot
6. Cari selisih nilai antara part 1 dan part 2 untuk mendapatkan angka kenaikan trend
7. Buat sebuah kolom baru bernama nilai prediksi
8. Isi kolom tersebut dengan pengurangan/penambahan berdasarkan jarak minus/plus dari part 1 dikalikan dengan angka kenaikan trend
9. Kolom terakhir inilah yang menjadi hasil peramalan dengan metode semi-average

Kelebihan metode semi average:
1. Model matematikanya relatif sederhanya, hanya kali-bagi-tambah-kurang
2. Hasil perhitungannya lebih dapat diandalkan karena menggunakan model matematis
2. Hasil perhitungannya lebih konsisten, terlepas dari siapa yang mencoba menghitungnya

Kekurangan metode semi average:
1. Perhitungan yang sederhana tidak selalu menghasilkan nilai ramalan yang akurat
2. Perhitungan yang menggunakan arithmatic mean selalu sensitif terhadap data ekstrim/outlier
3. Hanya bisa menghasilkan peramalan yang berdasarkan garis lurus

Cara membuat fungsi Semi Average di JS:
```
pivots = array => chunk(array, array.length/2).map(mean)
trend = array => (pivots(array)[1] - pivots(array)[0]) / (array.length/2)
semiAvg = array => withAs(
  pivots(array)[0], anchor => array.map(
    (i, j) => anchor + (trend(array) * j -
      array.findIndex(k => k === anchor)
    )
  )
)

semiAvg([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
// get [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
`pivots` itu adalah fungsi yang ketika diberikan sebuah deret angka maka akan membagi 2 panjang data tersebut dan memberikan 2 angka yang merupakan nilai tengah dari pembagian deret tersebut. Sebagai contoh, ketika dipanggil `pivots([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` maka JS akan mengembalikan `[3, 8]`. Hal ini masuk akal karena bila deret angka tersebut dibagi jadi 2 kelompok 1-5 dan 6-10 maka nilai tengah masing-masing adalah 3, dan 8.

`trend` itu adalah fungsi yang ketika diberikan sebuah deret angka, maka akan mencari selisih nilai grup pertama dan kedua lalu membaginya dengan panjang setengah deret. Kenapa disebut trend? Karena angka yang keluar adalah perkiraan statistik seberapa besar kenaikan nilai pada setiap suksesi/urutan. Sebagai contoh, ketika dipanggil `trend([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` maka JS akan mengembalikan nilai `1`. Artinya menurut statistik nilai peningkatan deret tersebut adalah 1 untuk setiap urutannya. Hal ini masuk akal, karena bisa kita lihat angka manapun dalam deret tersebut adalah lebih besar 1 poin dari nilai sebelumnya.

`semiAvg` itu adalah sebuah fungsi yang ketika diberikan sebuah deret angka, ia akan mengembalikan sebuah deret angka baru yang peningkatan setiap urutannya tergantung pada nilai trend yang diperoleh secara statistik. Pada contoh `semiAvg` diatas didapati bahwa dengan memanggil `semiAvg([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` akan mengembalikan `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`. Hal ini wajar karena secara statistik JS menemukan angka trend sebesar 1 dan membuat deret baru dengan nilai trend tersebut. Hal yang berbeda akan terjadi ketika kita memanggil `semiAvg([1, 2, 3, 4, 5, 5, 7, 8, 9, 10])`, silahkan dicoba sendiri.

Hanya membuat fungsi yang bisa memberikan kita deret angka baru yang berdasarkan matematika statistik mungkin kurang begitu bermanfaat untuk prediksi data kedepan. Untuk itu kita perlu membuat fungsi baru dengan logika yang sama yang mampu mengizinkan kita untuk melakukan prediksi data kedepan.

```
semiAvgN = (array, next = 0) => withAs(
  pivots(array)[0], anchor =>
    makeArray(array.length + next).map(
      (i, j) => anchor + (trend(array) * j -
        array.findIndex(k => k === anchor)
      )
    )
)

semiAvgN([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)
// get [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

`semiAvgN` adalah fungsi yang ketika diberikan sebuah deret angka berikut dengan panjang prediksi, maka akan mengembalikan sebuah deret angka baru yang setiap nilainya adalah hasil perhitungan berdasarkan angka trend sepanjang deret angka bahan ditambah dengan panjang prediksi. Coba perhatikan contoh pemanggilan `semiAvgN` diatas. Ketika diberikan deret angka 1-10 dengan increment/peningkatan 1, dan kita minta prediksi 2 suksesi setelahnya, komputer mengembalikan 12 deret angka yang merupakan hasil prediksi dengan menggunakan nilai trend. Nilai 11 dan 12 yang ditambakan pada deret angka baru masuk akal karena nilai trend yang ada di data bahan adalah 1.

Sekarang coba Anda panggil `semiAvgN([........], n)` dengan deret angka bebas sesuai keinginan Anda dan minta komputer untuk menghasilkan prediksi sepanjang `n` di masa depan. Bagaimana deret angka baru yang Anda temukan? Silahkan bereksperimen.

Kelebihan Metode Semi Average:
1. Mudah dimengerti dan menggunakan matematika sederhana
2. Bagus untuk data yang relatif linear dengan dispersi yang kecil
3. Lebih mendekati hasil prediksi dengan metode Freehand

Kekurangan Metode Semi Average:
1. Hanya berlaku untuk pola linear, jelek untuk pola lainnya
2. Pada data dengan dispersi besar, nilai prediksi akan banyak meleset
3. Terlalu sensitif terhadap data outlier, rentan meleset

## 6.3. Least Square
Least Square kalau diterjemahkan secara langsung artinya kuadrat terkecil. Lalu apa hubungannya kuadrat terkecil untuk prediksi? Disebut demikian karena kalau misalnya kita tarik sebuah garis dengan metode Freehand yang paling mewakili pola linier sebuah data maka nilai kuadrat selisih antara data asli dan prediksi adalah yang paling kecil, singkat kata, adalah yang paling akurat. Kalau metode Freehand adalah cara manusia menggunakan intusinya untuk membuat pola, Least Square adalah cara yang kita ajarkan kepada mesin untuk melakukan hal yang kurang lebih sama dengan cara manusia tersebut.

Berikut ini adalah formula matematis Metode Least Square: ![Gambar Formula Least Square]()
Kalau formula tersebut diterjemahkan menjadi kode JS maka bentuknya akan seperti kode dibawah ini:

```
isOdd = num => num % 2

middleIndex = length => isOdd(length) ?
makeArray(length).map((i, j) => j + 1 - Math.round(length / 2)) : [
  ...makeArray(length/2).reduce((res, inc) => [-1 + (-2*inc), ...res], []),
  ...makeArray(length/2).reduce((res, inc) => [...res, 1 + (2 * inc)], [])
]

leastSquareEqu = array => withAs(
  middleIndex(array.length), index => ({
  a: mean(array),
  b: sum(array.map((i, j) => i * index[j]))
    / sum(index.map(pow(2)))
}))

leastSquarePred = (array, next) => withAs({
  index: middleIndex(array.length),
  equation: leastSquareEqu(array)
}, ({index, equation}) => [
  ...index.map(i => equation.a + equation.b * i),
  ...makeArray(next).map(i =>
    equation.a + equation.b * (last(index)+i+1)
  )
])

leastSquareEqu([170, 190, 225, 250, 325])
// get {a: 232, b: 37}

leastSquarePred([170, 190, 225, 250, 325], 3)
// get [158, 195, 232, 269, 306, 343, 380, 417]
```

`isOdd` adalah fungsi yang ketika diberikan sebuah angka maka akan mengembalikan nilai benar bila angka tersebut adalah ganjil (ketika dibagi 2 hasilnya bukan bilangan bulat). Sementara ketika diberikan angka genap (bisa dibagi 2 dengan hasil bilangan bulat) akan mengembalikan nilai Salah. Anda boleh mencari contoh fungsi isOdd di internet dan kemungkinan akan mendapati contoh yang jauh lebih kompleks, sementara pada buku ini fungsi `isOdd` sangat pendek dan sederhana.

`middleIndex` adalah fungsi yang ketika diberikan sebuah angka maka akan memberikan sebuah deret angka yang isinya adalah nilai berurut tapi mulainya dari tengah. Semakin jauh ke kanan sebuah angka maka akan semakin besar nilai positifnya. Semakin jauh ke kiri sebuah angka maka akan semakin besar nilai negatifnya. Ada perbedaan set angka yang dikembalikan fungsi `middleIndex` tergantung panjang deret bahan yang diberikan itu ganjil atau genap. Bila angka yang diberikan adalah ganjil maka angka tengah yang mengawalinya adalah 0 dan kelanjutannya di sebelah kanan bernilai +1 dan seterusnya, begitu pula kelanjutan di sebelah kiri bernilai -1 dan seterusnya. Hal berbeda terjadi ketika kita berikan angka genap. Karena tidak ada nilai tengah tunggal, maka yang menjadi nilai tengah adalah -1 dan +1 sekaligus, dan setiap kelanjutan ke kanan adalah penambahan +2 dan kelanjutan deret sebelah kiri sebesar -2. Silahkan coba sendiri panggil `middleIndex(n)` dimana `n` adalah angka bebas yang boleh Anda tentukan sendiri dan lihat deret angkanya.

`leastSquareEqu` adalah fungsi yang ketika diberikan sebuah deret angka yang berasal dari data real maka akan mengembalikan nilai `a` dan `b`, dimana `a` adalah nilai konstanta dan `b` adalah nilai koefisien dari X. Jadi kalau pada buku pelajaran statistik lainnya Anda biasa melihat bahwa persamaan Least Square itu adalah `Y = a + bX` maka nilai yang dikeluarkan oleh fungsi ini adalah untuk mencari nilai `a` dan `b` itu. Nilai `a` sederhananya adalah mean dari deret tersebut, sementara nilai `b` adalah hasil pembagian P dan Q, dimana P adalah jumlah perkalian data real dan nilai middleIndex sesuai posisi relatif data tersebut, sementara Q adalah penjumlahan dari pangkat dua semua nilai middleIndex. Karena perhitungan nilai `a` hanya menggunakan `mean` makanya `a` menjadi konstan terlepas dari manapun posisi data yang sedang dihitung/diprediksi. Sementara nilai `b` perhitungannya tergantung pada posisi relatifnya terhadap middleIndex, makanya nilai `b` merupakan koefisien bagi X. Bagi yang berminat silahkan pelajari lebih dalam tentang logika fungsi Least Square di sumber lain seperti buku Matematika Statistik, Wikipedia, atau YouTube.

`leastSquarePred` adalah fungsi yang ketika diberikan sebuah deret angka maka akan memberikan sebuah deret angka baru yang merupakan hasil prediksi statistik secara matematis, ditambah dengan panjang prediksi yang kita harapkan. `leastSquarePred` ini memanfaatkan fungsi `leastSquareEqu` yang telah kita bahas tadi dan membuat deret angka baru yang merupakan hasil prediksi berikut dengan nilai prediksi kedepan yang kita tentukan. Pada contoh kode diatas dapat kita lihat hasil pemanggilan fungsi `leastSquarePred` ketika diberikan data dan nilai prediksi 3 periode kedepan. Dapat dilihat bahwa data kita yang awalnya hanya deret sepanjang 5 kini telah menjadi deret sepanjang 8 (5 prediksi dasar dan 3 prediksi kedepan). Jika Anda perhatikan dengan baik, dari contoh pemanggilan `leastSquareEqu` kita mendapati nilai 232 sebagai konstanta dan 37 sebagai koefisien variabel X. Dari persamaan ini kita tahu bahwa nilai tengah dari deret data asli adalah 232 dan setiap kali data bergerak ke kanan maka akan bertambah 37 poin dan akan berkurang 37 poin pada deret sebelah kiri. Semakin jauh data ke kanan maka akan terus ditambah dengan kelipatan 37 poin. Karena pertambahan nilai sebesar 37 poin dan tidak berubah inilah makanya persaman ini disebut linier.

Sekarang silahkan Anda coba karang sendiri deret angka (bebas berapa digit) dengan pola peningkatan atau penurunan yang linier (tidak harus tepat) dan coba panggil dengan `leastSquarePred` berikut dengan panjang prediksi yang diharapkan. Bila Anda ingin memahami mengapa komputer mengembalikan deret angka seperti itu, coba panggil data yang sama dengan `leastSquareEqu`, maka akan keluar nilai `a` yang merupakan konstanta dari data karangan Anda, dan nilai koefisien `b` variabel X yang secara statistik diprediksikan oleh komputer Anda. Jangan marah/kecewa bila hasil prediksi relatif jauh dari data real, bisa jadi data karangan Anda memang tidak berpola linear.

Kelebihan Metode Least Square:
1. Hasil prediksi relatif lebih akurat daripada 2 metode sebelumnya
2. Bisa sekalian tahu konstanta dan koefisien X yang membentuk garis liniernya

Kekurangan Metode Least Square:
1. (Bisa jadi) kalah akurat dibanding regresi linear
2. Tetap over-sensitif terhadap data outlier yang bisa merusak hasil prediksi

## 6.4. Parabolic Trend
Semua fungsi/persamaan yang telah kita bahas sebelumnya hanya cocok untuk menghadapi situasi dimana suatu set data memiliki pola yang liner/lurus. Ketika kita dihadapkan pada data yang berpola tidak-lurus, bengkok, dan kurva, semua alat yang diatas sama sekali tidak bisa dipakai. Kalau dipaksakan justru akan merusak hasil prediksi dan mengantarkan kita ke kesimpulan yang salah. Lalu bagaimana bila sebuah data ketika dipetakan dalam grafik memiliki pola yang terlihat berbentuk kurva seperti parabola? Adakah cara statistik yang bisa digunakan untuk melakukan prediksi pada set data yang seperti itu? Jawabannya ada, kita akan menggunakan Parabolic Trend. Parabolic Trend adalah formula statistik yang memungkinkan ahli statistik untuk mencari sebuah kurva trend (kurva, bukan garis lagi ya) yang paling akurat mendekati pola yang ada pada data. Tanpa mengandalkan formula Parabolic Trend sekalipun sebenarnya bisa saja kita menggunakan metode Freehand lagi untuk membuat kurva trend sendiri dengan mengandalkan intuisi dan pengalaman, sayangnya hal tersebut tidak reliabel dan dapat dipertanggungjawabkan secara ilmiah. Serupa dengan pola pikir Least Square sebelumnya, Parabolic Trend adalah cara kita mengajarkan kepada komputer bagaimana mencari sebuah kurva trend yang paling mendekati pola kurvatur pada data tanpa bantuan manusia. Dari sumber internet, kita peroleh bahwa formula matematis dari metode Parabolic Trend ini adalah seperti pada gambar berikut: ![Gambar formula Parabolic Trend]()

Dan jika diterjemahkan menjadi kode JS maka akan menjadi seperti berikut:
```
parabolicTrend = array => withAs(
  middleIndex(array.length), index => withAs({
    length: array.length,
    SY  : sum(array), length: array.length,
    SXY : sum(index.map((i, j) => array[j] * i)),
    SX2Y: sum(index.map((i, j) => array[j] * i * i)),
    SX2 : sum(index.map(pow(2))),
    SX4 : sum(index.map(pow(4))),
  }, ({length, SY, SXY, SX2Y, SX2, SX4}) => ({
    a: (length * SX2Y - SX2 * SY) /
       (length * SX4 - pow(2)(SX2)),
    b: SXY / SX2,
    c: (SY * SX4 - SX2Y * SX2) /
       (length * SX4 - pow(2)(SX2))
  }))
)

parabolicTrend([12, 16, 19, 21, 22])
// get {a: -0.5, b: 2.5, c: 19}
// equal to -0.5X^2 + 2.5X + 19

parabolicTrendPred = (array, next) => withAs({
  index: middleIndex(array.length),
  equation: parabolicTrend(array)
}, ({index, equation}) => [
  ...index.map(i =>
    equation.a * i * i +
    equation.b * i +
    equation.c
  ),
  ...makeArray(next).map(i =>
    equation.a * pow(2)(1 + i + last(index)) +
    equation.b * (1 + i + last(index)) +
    equation.c
  )
])

parabolicTrendPred([12, 16, 19, 21, 22], 5)
// get [12, 16, 19, 21, 22, 22, 21, 19, 16, 12]
//     [-----raw data-----|-----predicted-----]
```
